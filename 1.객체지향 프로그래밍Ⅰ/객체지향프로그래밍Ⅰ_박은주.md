---
created: 2022-11-15
title: 자바스터디_06_객체지향프로그래밍
author: pej
category: study
tag: study
aliases: []
---

#### 책 목차
	- 객체지향언어
	- 클래스와 객체
	- 변수와 메서드
	- 오버로딩
	- 생성자
	
#### 학습할 것
	- 클래스와 객체를 만드는 방법
	- new 연산자 이해하기
	- 생성자를 정의하는 방법
	- this 연산자 이해하기
	- 오버로딩을 만드는 방법

#### 학습 내용

1.  클래스와 객체
	+ 클래스 : 객체를 생성하는데 사용되며, 객체의 설계도라고 생각하면됨
	+ 객체 : 모든 인스턴스를 포괄적으로 의미

	>  인스턴스(instance) : 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 표현<br>
	>  인스턴스화(instantiate) : 객체를 만드는 과정<br>
	>  문맥에 따라서 객체와 인스턴스 용어를 구별하여 사용하는 것이 좋음<br>
	> 	+ TV는 인스턴스다(X) => TV는 객체다(O)
	> 	+ TV는 TV클래스의 객체다(X) => TV는 TV클래스의 인스턴스이다 (O)

2. 객체의 생성 및 사용법
```
방법1)
클래스명 변수명;
변수명 = new 클래스명;
변수명.멤버변수 = 값;

방법2)
클래스명 변수명 = new 클래스명;
변수명.멤버변수 = 값;

// 컴퓨터 클래스의 참조변수 선언
Computer computer;         
// 컴퓨터 클래스의 인스턴스 생성후 생성된 인스턴스의 주소를 참조변수에 저장
// 컴퓨터 클래스의 멤버변수는 각 자료형의 해당하는 기본값으로 초기화됨
computer = new Computer(); 
computer.computerName = "computer";
```

+ 인스턴스는 참조변수를 통해서만 사용 할 수 있다.
+ 참조변수의 타입은 인스턴스의 타입과 일치해야한다.

> new 연산자
> + **인스턴스 생성시 사용하는 연산자**
> + 수행 순서
> 	1. JVM 메모리 Heap영역에 저장 공간을 할당
> 	2. 생성자를 호출
> 	3. 인스턴스의 주소가 반환하여 참조변수에 저장

3. 변수와 메서드
- 변수
	- 데이터를 저장 할 수 있는 메모리 공간을 의미

- 변수의 종류

	| 종류          | 위치        | 생성시기                    | 내용                                            |
	| :-------------| ---------------| :--------------------------- | :----------------------------------------------- |
	| 클래스 변수   | 클래스 영역     | 클래스가 메모리에 올라갈 때 | 모든 인스턴스가 공통적인 값을 유지해야하는 경우 사용하며 <br>인스턴스를 생성하지 않고도 바로 접근 가능함 |
	| 인스턴스 변수 | 클래스 영역     | 인스턴스가 생성되었을 때    | 인스턴스 마다 고유한 값을 유지해야하는 경우     |
	| 지역 변수     | 클래스 영역 이외| 변수 선언문이 실행되었을 때| 해당 영역에서만 사용 가능하며 영역을 벗어나면 소멸                                                 |

	```
	class Variable {
	    // 멤버 : 멤버변수 + 메서드
	    // 멤버변수 : 인스턴스 변수 + 클래스 변수
	    int instanceVar = 1; // 인스턴스 변수
	    static int classVar = 100 ; // 클래스변수(satice 변수) : 공유변수
		
	    void test() {
	        int localVar = 0; // 지역변수
	    }
	}
	
	class Main {
	    public static void main(String[] args) {
	        System.out.println("## 클래스변수 => " + Variable.classVar);
	        Variable test1 = new Variable();
	        test1.instanceVar = 200;
	        
	        Variable test2 = new Variable();
	        System.out.println("## 인스턴스 변수 test1 => " + test1.instanceVar);
	        System.out.println("## 인스턴스 변수 test2 => " + test2.instanceVar);
	    }
	}
	```
- 변수의 초기화
	- 멤버변수는 초기화를 따로 하지 않아도 자료형 타입에 맞게 기본값으로 초기화가 됨
	- **지역변수는 반드시 초기화를 해야함**
	- 멤버변수의 초기화 방법
		- 명시적 초기화
			- 선언과 동시에 초기화 하는 방법
		- 생성자
		- 초기화 블럭(클래스 초기화 블럭, 인스턴스 초기화 블럭)[^1]
			- 메서드내에 조건문, 반복문 등을 자유롭게 사용 할 수 있으며 생성자보다 먼저 수행됨
			 ```
			class Test {
				satic {
					// 클래스 초기화 블럭
				}
				{
					// 인스턴스 초기화 블럭
				}
			}
			```
	> 멤버변수의 초기화 시점과 순서
	> + 클래스 변수
	> 	+ 클래스가 처음 로딩될 때 한번 초기화
	> 	+ 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
	> + 인스턴스 변수
	> 	+ 인스턴스가 생성될 때마다 각각 초기화
	> 	+ 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
- 메서드
	- 특정 작업을 하는 문장들을 모아놓은 것으로 높은 재사용성과 중복된 코드를 제거 할 수 있기 때문에 사용함
	- 메서드의 기본 구조
	```
	반환타입 메서드이름 (변수타입 변수명, ...) {
		// 로직 처리
		// 반환 타입이 있다면 return문 추가
	}
	
	int add(int num1, int num2) {
		return num1 + num2;
	}
	
	void test(String str) {
		// 반환타입이 void이기 때문에 return문 없어도 됨
		// 컴파일러가 자동으로 return문을 추가해줌
		return;
	}
	```

	- return문의 타입과 전달할 파라미터의 타입이 일치하거나 자동 형변환이 가능한 것이여야하며 메소드 매개변수(parameter)도 return문과 동일함
	- **어디에서 이상한 값이 들어올지 모르기때문에 매개변수 유효성 검사는 반드시 넣는게 좋음**
	- 메서드의 종류
	
		| 종류          | 위치        | 생성시기                    | 내용                                                                   |
		| ------------- | ----------- | --------------------------- | ---------------------------------------------------------------------- |
		| 클래스 메소드 | 클래스 영역 | 클래스가 메모리에 올라갈 때 | 클래스 변수와 비슷하며 클래스 메소드에서는 클래스 변수만 사용이 가능함 |
		| 인스턴스 메소드|클래스 영역|인스턴스가 생성되었을 때| 인스턴스 변수와 비슷하며 인스턴스 메소드는 인스턴스 변수만 사용이 가능함|
	- 기본형 매개변수/반환타입, 참조형 매개변수/반환타입
		- 기본형, 참조형 타입에 따라서 메서드 호출시 복사되는 것이 달라짐
		- 기본형(primitive type) 매개변수/반환타입 : 변수의 값이 복사됨
		- 참조형(reference type) 매개변수/반환타입 : 변수의 주소값이 복사됨
		```
		class Parameter {
		    int num = 10;
		}
		
		class Main {
		    public static void main(String[] args) {
			    // 기본형 매개변수 : param.num의 값이 그대로 유지되었음 
		        Parameter param = new Parameter();
		        System.out.println("[변경전] param.num => " + param.num);
		        change(param.num);
		        System.out.println("[변경후] param.num => " + param.num);
		        
		        // 참조형 매개변수 : param2.num의 값이 변경되었음
			    Parameter param2 = new Parameter();
		        System.out.println("[변경전] param2.num => " + param.num);
		        change(param2);
		        System.out.println("[변경후] param2.num => " + param.num);
		    }
		
		    static void change(int x) {
		        x = 1000;
		        System.out.println("[change] x => " + x);
		    }
		    
			static void change(Parameter p) {
		        p.num = 1000;
		        System.out.println("[change] num => " + p.num);
		    }
		}
		
		[결과]
		==============================
		[변경전] param.num => 10
		[change] x => 1000
		[변경후] param.num => 10
		
		[변경전] param2.num => 10
		[change] num => 1000
		[변경후] param2.num => 10
		```

4. 오버로딩(Overloading)
	- 한 클래스 내에 동일한 이름을 가진 메서드를 여러 개 정의하는 것을 의미함
	- 오버로딩의 조건
		- 메서드 이름이 같아야 함
		- 매개변수의 개수 또는 타입이 달라야 함
	- **반환 타입은 영향을 주지 못함**
> 가변인자(varargs)
> + 메서드의 매개변수를 동적으로 지정 할 수 있게 해주는 기능으로 JDK 1.5부터 추가되었음
> + 가변인자와 매개변수 혼용시 가변인자가 마지막에 있어야 하며 그 이유는 가변인자를 구별할 방법이 없기 때문
> + 사용법 : '타입... 변수명'
> + 내부적으로 배열을 이용하며 메서드 호출시마다 새로운 배열을 만들어서 사용함
> + 가변인자가 있는 메서드를 오버로딩했을 경우 구별하지 못하는 경우가 있기때문에 가능하면 오버로딩 하지 않는것이 좋음

5. 생성자(Constructor)
	- 생성자 
		- 모든 클래스는 생성자를 가져야 하며 **인스턴스 초기화 메서드**라고 불림
		- 인스턴스 생성 시에 실행되어야 할 작업(인스턴스 변수 초기화 작업)을 위해서 사용함
	- 생성자의 조건
		- 생성자의 이름은 클래스 이름과 동일해야 함
		- 생성자는 반환값이 없음
		```
		클래스(타입 변수명, ...) {
			// 인스턴스 초기화 작업
		}
		class Test() {
			int num;
			String str;
			
			// 기본 생성자
			Test() {
			}
			// 매개변수가 있는 생성자
			Test(int num, String str) {
				this.num = num;
				this.str = str;
			}
			// 생성자에서 다른 생성자 호출
			Test(int num) {
				this(num, "test");
			}
		}
		
		Test t1 = new Test(); // 기본 생성자를 이용
		Test t2 = new Test(1, "테스트"); //  매개변수가 있는 생성자를 이용
		
		```
		> 기본 생성자 vs 매개변수가 있는 생성자
		> + 기본 생성자 : 클래스에 정의된 생성자가 하나도 없는 경우 컴파일러가 알아서 넣어줌
		> + 매개변수가 있는 생성자 : 인스턴스 변수를 각기 다른 값으로 초기화 할때 사용하면 편리함
		
		> this vs this()
		> + this : 인스턴스 자신을 가리키는 참조변수로 인스턴스 메서드에서만 사용이 가능함(sataic 메서드는 인스턴스 생성하지 않고도 사용 할 수 있기때문에) 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재함
		> + this() : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
		> 
#### 출처(참고문헌)
- Java의 정석
- http://www.tcpschool.com/java/java_datatype_variable
- https://devlogofchris.tistory.com/35

#### 연결문서
-

#### 각주
[^1]: 프로젝트를 하면서 초기화 블럭을 사용하는 것을 보지 못하였다. 보편적으로 사용하지 않는 이유가 무엇일까?
