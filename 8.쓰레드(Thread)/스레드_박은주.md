---
created: 2023-02-04
title: 스레드_박은주
author: pej
category: study
tag: study
aliases: 
---

#### 책 목차
- 프로세스와 스레드
- 스레드의 구현과 실행
- start()와 run()
- 싱글스레드와 멀티스레드
- 스레드의 우선순위
- 스레드 그룹
- 데몬 스레드
- 스레드의 실행제어
- 스레드의 동기화
#### 학습할 것
- 스레드 만드는 방법
- start()와 run()의 차이
- 스레드 실행제어 하는 방법
- 스레드 동기화 방법

#### 학습 내용
1. 스레드(Thread)
	+ **프로그램(프로세스)안에 실행되는 흐름 단위**
	+ 스레드 만드는 방법
		+ **Thread 클래스 상속**
		+ **Runnalbe 인터페이스 구현**
		```
		// 방법1) Thread 클래스 상속
		Thread1 t1 = new Thread1();
		t1.setName("이것은 스레드 테스트1");
		t1.setPriority(1);
		t1.start();
		
		// 방법2) Runnalbe 인터페이스 구현
		Runnable run = new Thread2();
		Thread t2 = new Thread(run);
		t2.start();
		
		Thread t2 = new Thread(new Thread2());
		t2.start();
		```
	+ 멀티 스레드인 경우 OS의 프로세스 스케줄러의 영향을 받기 때문에 실행순서와 실행시간이 상황에 따라 다를수 있음
	+ 스레드의 우선수위
		+ 우선순위에 따라서 얻을 수 있는 실행시간이 달라짐
		+ 1~10까지 가능하며 숫자가 높을수록 실행시간이 길어짐
		+ main()에서 실행되는 스레드는 기본적으로 우선순위 `5`로 되어 있음
		+ **OS의 스케줄러의 영향을 많이 받기 때문에 차라리 PriorityQueue에 저장하는 것이 더 명확할 수 있음**
	+ 스레드 그룹
		+ **모든 스레드는 그룹이 있어야하며** JVM에서 main, system 이라는 그룹을 자동으로 만들어줌
		+ 그룹을 지정하지 않으면 자동적으로 main 스레드 그룹으로 지정됨
		+ 보안상의 이유로 도입되었으며 자신이 속한 스레드 그룹, 하위 스레드 그룹만 변경 할 수 있음
		```
		public class TestThread {
		    private static Logger logger = LogManager.getLogger(TestThread.class);
		    
		    static class Thread4 extends Thread {
		        @Override
		        public void run() {
		            logger.debug("ID : {} / Name : {} / Priority : {} / ThreadGroup : {}", getId(), getName(), getPriority(), getThreadGroup());
		        }
		    }
		    
		    static class Thread5 implements Runnable {
		        @Override
		        public void run() {
		            logger.debug("ID : {} / Name : {} / Priority : {} / ThreadGroup : {}", Thread.currentThread().getId(), Thread.currentThread().getName(), Thread.currentThread().getPriority(), Thread.currentThread().getThreadGroup());
		        }
		    }
		        
		    public static void test3() {
		        ThreadGroup tGroup1 = new ThreadGroup("그룹1");
		        tGroup1.setMaxPriority(4);
		        
		        ThreadGroup tGroup2 = new ThreadGroup(tGroup1, "서브그룹");
		        tGroup2.setMaxPriority(3);
		        
		        Thread t4 = new Thread(tGroup1, new Thread4(), "스레드 그룹 테스트1");
		        t4.start();
		        
		        Thread t5 = new Thread(tGroup1, new Thread5(), "스레드 그룹 테스트2");
		        t5.start();
		        
		        Thread t6 = new Thread(tGroup2, new Thread5(), "스레드 그룹 테스트3");
		        t6.start();
		        
		        // 스레드 그룹 정보 출력
		        // getAllStackTraces() : 실행되는 모든 스레드 정보를 가져옴
		        Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
		        for (Thread item : map.keySet()) {
		            System.out.println(item); 
		        }
		    }
		    
		    public static void main(String[] args) {
		        test3();
		    }
		}
		
		[실행결과]
		Thread[스레드 그룹 테스트3,3,서브그룹]
		Thread[스레드 그룹 테스트1,4,그룹1]
		Thread[Finalizer,8,system]
		Thread[main,5,main]
		Thread[Attach Listener,5,system]
		Thread[스레드 그룹 테스트2,4,그룹1]
		Thread[Reference Handler,10,system]
		Thread[Signal Dispatcher,9,system]
		ID : 17 / Name : 스레드 그룹 테스트3 / Priority : 3 / ThreadGroup : java.lang.ThreadGroup[name=서브그룹,maxpri=3]
		ID : 16 / Name : 스레드 그룹 테스트2 / Priority : 4 / ThreadGroup : java.lang.ThreadGroup[name=그룹1,maxpri=4]
		ID : 14 / Name : Thread-1 / Priority : 5 / ThreadGroup : java.lang.ThreadGroup[name=main,maxpri=10]
		```
    + 스레드의 실행제어
	    + sleep() : 현재 실행중인 스레드를 일정시간동안 일시정지
	    + yield() : 할당받은 실행시간을 다른 스레드로 양보
	    + join() : 다른 스레드가 종료될때까지 기다림
    + 스레드의 동기화
	    + **임계 영역(Critical Section) : 공유 데이터를 사용하는 코드 영역**
	    + 잠금(Lock) : 가지고 있어야 임계 영역을 수정 할 수 있음
	    + 스레드의 동기화 : 한 스레드가 임계 영역에서 작업하고 있으면 다른 스레드가 임계 영역을 변경 할 수 없게 하는 것
		+ 동기화 방법
			+ synchronized 이용
			 ```
			방법1) 메서드 전체를 지정
			public synchronized void test() { }
			
			방법2) 특정 영역을 지정
			synchronized { }
			```
			+ Lock과 Condition 이용

#### 출처(참고문헌)
 - Java의 정석
 - https://hamait.tistory.com/612
#### 연결문서
-

#### 각주
